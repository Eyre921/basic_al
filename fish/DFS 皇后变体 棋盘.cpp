#include <iostream>
using namespace std;

const int N = 10;  // 最大棋盘尺寸
int n, k;
char g[N][N];  // 存储棋盘的形状
bool col[N];  // 记录每列是否有棋子
long long res = 0;  // 记录总的方案数

// 回溯函数
void dfs(int u, int epo) {
    if (epo == k) {  // 如果已经放置了 k 个棋子
        res++;
        return;
    }

    if (u == n) return;  // 已经遍历到棋盘的最后一行

    for (int i = 0; i < n; i++) {
        if (!col[i] && g[u][i] == '#') {  // 当前行的第 i 列可以放棋子
            col[i] = true;  // 标记列 i 已经有棋子
            dfs(u + 1, epo + 1);  // 尝试放置棋子，递归到下一行
            col[i] = false;  // 撤销放置棋子的操作，继续探索
        }
    }

    // 不放棋子，尝试递归到下一行
    dfs(u + 1, epo);
}

int main() {
    while (true) {
        cin >> n >> k;  // 输入棋盘的尺寸和需要摆放的棋子数
        if (n == -1 && k == -1) break;  // 输入结束的标志

        // 读取棋盘形状
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cin >> g[i][j];
            }
        }

        res = 0;  // 重置结果
        fill(begin(col), end(col), false);  // 初始化列占用标记

        // 从第一行开始尝试
        dfs(0, 0);

        cout << res << endl;  // 输出当前棋盘的方案数
    }
    return 0;
}

/*
在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。

要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案数目 C。

输入格式
输入含有多组测试数据。

每组数据的第一行是两个正整数 n,k，用一个空格隔开，表示了将在一个 n∗n 的矩阵内描述棋盘，以及摆放棋子的数目。当为-1 -1时表示输入结束。

随后的 n行描述了棋盘的形状：每行有 n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。

输出格式
对于每一组数据，给出一行输出，输出摆放的方案数目 C
 （数据保证 C<231
）。

数据范围
n≤8,k≤n

输入样例：
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
输出样例：
2
1
 */