#include <bits/stdc++.h>
using namespace std;

int n, m;  // n为火星人的手指数目，m为要加的整数
const int N = 1e5 + 10;  // 定义一个足够大的常数N，存储手指排列及其他状态
int arr[N], mars[N];  // arr[] 存储当前的排列，mars[] 存储火星人手指的排列顺序
bool st[N];  // st[] 标记某个位置是否已经被访问过，用于DFS
int res = 0;  // 记录当前已经找到的排列数量
bool alfind = false;  // 标志是否已经找到了第 m+1 个排列

// 深度优先搜索函数，x为当前递归的层次
void dfs(int x)
{
    if (alfind) return;  // 如果已经找到了第m+1个排列，则停止递归

    if (x > n)  // 当递归的层数超过了n，说明当前排列已经完整
    {
        res++;  // 增加当前排列数量
        if (res == m + 1)  // 如果达到了目标排列数量m+1
        {
            alfind = true;  // 标记已经找到了
            for (int i = 1; i <= n; i++)  // 输出当前排列
                cout << arr[i] << " ";
        }
        return;
    }

    // 递归生成下一个排列
    for (int i = 1; i <= n; i++)  // 遍历可能的手指位置
    {
        if (!res)  // 这里有点奇怪的逻辑，可能是为了优化递归的顺序
        {
            i = mars[x];  // 这行的作用不清晰，可能是一个错误的处理逻辑
        }

        if (!st[i])  // 如果当前位置还没有被访问过
        {
            st[i] = true;  // 标记当前位置为已访问
            arr[x] = i;  // 记录当前的手指位置
            dfs(x + 1);  // 递归处理下一个手指位置
            st[i] = false;  // 回溯，取消访问标记
            arr[x] = -1;  // 清除当前位置
        }
    }
}

int main()
{
    scanf("%d %d", &n, &m);  // 输入火星人手指的数目n和要加的小整数m
    for (int i = 1; i <= n; i++) scanf("%d", &mars[i]);  // 输入火星人手指的排列顺序

    dfs(1);  // 从第1个手指开始递归

    // 程序结束时如果没有找到第m+1个排列则不会输出
}

/*
#include <bits/stdc++.h>

using namespace std;
int n, m;
const int N = 1e5 + 10;
int arr[N], mars[N];
bool st[N];
int res = 0;
bool alfind = false;

void dfs(int x)
{
    if (alfind) return; //点睛之笔！！！
    if (x > n)
    {
        res++;
        if (res == m + 1)
        {
            alfind = true;
            for (int i = 1; i <= n; i++) cout << arr[i] << " ";
        }
        return;
    }
    for (int i = 1; i <= n; i++)
    {
        if (!res)
        {
            i = mars[x];
        }
        if (!st[i])
        {
            st[i] = true;
            arr[x] = i;
            dfs(x + 1);
            st[i] = false;
            arr[x] = -1;
        }
    }
}

int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &mars[i]);
    dfs(1);
}
*/
/*
# [NOIP2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。

## 输入格式

共三行。
第一行一个正整数 $N$，表示火星人手指的数目（$1 \le N \le 10000$）。
第二行是一个正整数 $M$，表示要加上去的小整数（$1  \le  M  \le  100$）。
下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。

## 输出格式

$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。

## 样例 #1

### 样例输入 #1

```
5
3
1 2 3 4 5
```

### 样例输出 #1

```
1 2 4 5 3
```

## 提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题
 */
