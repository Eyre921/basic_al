

#include <bits/stdc++.h>
using namespace std;

const int N = 15;  // 最大元素数量
int suan[N], ku[N], st[N];  // suan[i]：元素的乘积系数，ku[i]：元素的苦度，st[i]：选择状态（0: 未选择，1: 选，2: 不选）
int n, res = 0, ans = 1e9;  // n: 元素数量，res: 当前的差值，ans: 最小的差值（初始化为一个较大的值）

// 深度优先搜索函数
void dfs(int x, int s, int k) {
    if (x > n) {  // 如果遍历完所有元素
        if (k == 0) return;  // 如果没有任何元素被选中，苦度为0，直接返回
        res = abs(s - k);  // 计算乘积s和苦度k的差的绝对值
        ans = min(res, ans);  // 更新最小差值
        return;
    }

    // 情况1：选择当前元素
    st[x] = 1;  // 标记元素x为选中
    dfs(x + 1, s * suan[x], k + ku[x]);  // 继续递归处理下一个元素
    st[x] = 0;  // 回溯，恢复选择状态

    // 情况2：不选择当前元素
    st[x] = 2;  // 标记元素x为不选
    dfs(x + 1, s, k);  // 继续递归处理下一个元素
    st[x] = 0;  // 回溯，恢复选择状态
}

int main() {
    cin >> n;  // 输入元素数量
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &suan[i], &ku[i]);  // 输入每个元素的乘积系数和苦度
    }

    dfs(1, 1, 0);  // 从第一个元素开始，初始乘积为1，初始苦度为0
    cout << ans << endl;  // 输出最小差值
}

/*
# [COCI2008-2009 #2] PERKET

## 题目描述

Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。

众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。

另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。

## 输入格式

第一行一个整数 $n$，表示可供选用的食材种类数。

接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。

## 输出格式

一行一个整数，表示可能的总酸度和总苦度的最小绝对差。

## 样例 #1

### 样例输入 #1

```
1
3 10
```

### 样例输出 #1

```
7
```

## 样例 #2

### 样例输入 #2

```
2
3 8
5 8
```

### 样例输出 #2

```
1
```

## 样例 #3

### 样例输入 #3

```
4
1 7
2 6
3 8
4 9
```

### 样例输出 #3

```
1
```

## 提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。
#### 说明
- 本题满分 $70$ 分。

*/


/*
#include <bits/stdc++.h>
using namespace std;
const int N = 15;
int suan[N], ku[N],st[N];
//st[N] 0 不知道，1选，2不选
int n, res = 0, ans = 1e9;

void dfs(int x, int s, int k)
{
    if (x > n) //遍历到终点
    {
        if (k == 0) return; //如果没有加则苦度为0
        res = abs(s - k);
        ans = min(res, ans);
        return;
    }

    st[x] = 1;
    dfs(x + 1, s * suan[x], k + ku[x]);
    st[x] = 0;

    st[x] = 2;
    dfs(x + 1, s, k);
    st[x] = 0;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) scanf("%d%d", &suan[i], &ku[i]);
    dfs(1, 1, 0);
    cout << ans << endl;
}
*/