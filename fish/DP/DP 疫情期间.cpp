#include <iostream>
#include <algorithm>  // 用于min函数
using namespace std;

/*
本问题可以通过动态规划来解决。状态转移方程如下：
- dp[i][0]：表示第i天休息的最小休息天数
- dp[i][1]：表示第i天进行编程的最小休息天数
- dp[i][2]：表示第i天进行健身的最小休息天数

在处理每一天的决策时，状态转移需要依赖前一天的状态。
*/

int a[110]; // a[i]表示第i天的活动限制（1表示编程，2表示健身，3表示可以编程或健身）
int dp[110][3]; // dp[i][0]为休息，dp[i][1]为编程，dp[i][2]为健身，表示第i天选择的活动最小休息天数

int main()
{
    int n; // n表示天数
    cin >> n;

    // 输入每一天的活动限制
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }

    // 初始化动态规划数组，使用一个较大的数字作为无效初始值
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            dp[i][j] = 10000; // 设定一个大数，表示初始时没有解
        }
    }

    // 动态规划的初始状态，第1天的选择
    if (a[1] == 1) dp[1][1] = 0; // 第1天只能编程
    else if (a[1] == 2) dp[1][2] = 0; // 第1天只能健身
    else if (a[1] == 3) dp[1][1] = 0, dp[1][2] = 0; // 第1天可以选择编程或健身
    dp[1][0] = 1; // 第1天如果休息，则休息天数加1

    // 从第2天开始处理
    for (int i = 2; i <= n; i++)
    {
        if (a[i] == 1) dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]); //  // 如果今天只能编程 前一天只能是休息或健身
        else if (a[i] == 2) dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]); //// 如果今天只能健身 前一天只能是休息或编程
        else if (a[i] == 3)
        {
            // 如果今天既可以编程也可以健身
            dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]); // 前一天只能是休息或健身
            dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]); // 前一天只能是休息或编程
        }
        // 如果今天休息，休息天数加1
        dp[i][0] = 1 + min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]));
    }

    // 输出最小的休息天数（无论最后一天做什么活动）
    cout << min(dp[n][0], min(dp[n][1], dp[n][2])) << '\n';

    return 0;
}
