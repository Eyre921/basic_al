#include <iostream>     // 引入输入输出流库，用于读取输入和输出结果
#include <string.h>     // 引入字符串处理库，主要用于内存操作函数如 memset
#include <string>       // 引入字符串类库
using namespace std;

typedef pair<int, int> PII; // 定义一个类型别名PII，表示一个整数对，用于存储网格的坐标

int m, n; // m表示网格的列数，n表示网格的行数
const int N = 505; // 定义网格的最大尺寸，防止数组越界
int high[N][N], flag[N][N]; // high数组存储每个格子的海拔高度，flag数组标记哪些格子是路标（1表示路标，0表示非路标）
bool st[N][N]; // st数组用于标记在搜索过程中某个格子是否已经被访问过
PII q[N * N + 10]; // 定义一个队列q，用于广度优先搜索（BFS），存储待处理的格子的坐标
int cnt_flat = 0; // cnt_flat记录需要访问的路标数量
int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0}; // dx和dy数组定义了四个方向（东、西、南、北）的移动偏移量
int x1, y1; // x1和y1存储第一个路标的坐标，用作BFS的起点

// check函数用于判断在给定的难度系数D（mid）下，是否可以使所有路标相互可达
bool check(int mid)
{
    q[0] = {x1, y1}; // 将起始路标点加入队列
    st[x1][y1] = true; // 标记起始路标点为已访问
    int hh = 0, tt = 0; // 初始化队列的头尾指针
    int cnt = 1; // 已访问的路标数量，初始为1（起点本身是路标）

    while (hh <= tt) // 当队列不为空时继续搜索
    {
        auto t = q[hh++]; // 取出队列中的第一个元素
        for (int i = 0; i < 4; i++) // 遍历四个方向
        {
            int a = t.first + dx[i], b = t.second + dy[i]; // 计算相邻格子的坐标
            // 检查新坐标是否在网格范围内
            if (a < 1 || a > n || b < 1 || b > m) continue;
            // 如果该格子已经被访问过，则跳过
            if (st[a][b]) continue;
            // 如果相邻格子的海拔高度差超过当前难度系数mid，则无法通过，跳过
            if (abs(high[a][b] - high[t.first][t.second]) > mid) continue;
            // 标记该格子为已访问
            st[a][b] = true;
            q[++tt] = make_pair(a, b); // 将该格子加入队列
            if (flag[a][b] == 1) // 如果该格子是路标
            {
                cnt++; // 增加已访问的路标数量
                if (cnt_flat == cnt) return true; // 如果所有路标都已访问，返回true
            }
        }
    }
    return false; // 如果无法访问所有路标，返回false
}

int main()
{
    cin >> n >> m; // 输入网格的行数n和列数m

    // 读入网格的海拔高度信息
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) scanf("%d", &high[i][j]);

    // 读入路标信息，1表示该格子是路标，0表示非路标，并统计路标的总数cnt_flat
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            scanf("%d", &flag[i][j]);
            if (flag[i][j] == 1)
            {
                cnt_flat++;
                x1 = i, y1 = j;// 找到随机一个路标的坐标作为BFS的起点(x1, y1)
            }
        }




    int l = -1, r = 1000000010; // 初始化二分查找的上下界，l为-1，r为一个足够大的值
    while (l + 1 < r) // 当搜索范围尚未收敛时继续
    {
        int mid = (l + r) >> 1; // 计算中间值mid作为当前的难度系数D
        memset(q, 0, sizeof(q)); // 重置队列q
        memset(st, false, sizeof(st)); // 重置访问标记st
        if (check(mid)) // 如果在当前mid下所有路标都可达
        {
            r = mid; // 将上界缩小为mid
        } else l = mid; // 否则，将下界增大为mid
    }
    cout << r << endl; // 输出最小满足条件的难度系数D
}

/*
当然，我很高兴为您详细解释这段代码的思路，以及为何从一个起点进行遍历能够正确地解决“汽车拉力比赛”问题。

## 问题概述

**题目**：在一个 $N \times M$ 的网格中，每个格子有一个海拔高度。某些格子被标记为路标。我们需要找到一个最小的难度系数 $D$，使得任意两个路标之间存在一条路径，使得路径上相邻格子的海拔高度差不超过 $D$。

**目标**：找到最小的 $D$，确保所有路标相互可达。

## 思路概述

为了解决这个问题，采用了**二分查找**结合**广度优先搜索（BFS）**的方法：

1. **二分查找**：
   - 定义一个搜索范围 $[l, r]$，初始设定为 $l = -1$ 和 $r = 10^9 + 10$。
   - 通过不断缩小这个范围，找到最小的 $D$，使得在该 $D$ 下，所有路标都是连通的。

2. **广度优先搜索（BFS）**：
   - 对于每一个中间值 $mid = \frac{l + r}{2}$，检查是否存在一个路径，使得所有路标在高度差不超过 $mid$ 的条件下相互可达。
   - 如果存在，则尝试更小的 $D$（缩小右边界 $r$）。
   - 否则，尝试更大的 $D$（增大左边界 $l$）。

## 详细步骤

### 1. 输入与初始化

- **输入**：
  - 网格的行数 $n$ 和列数 $m$。
  - 每个格子的海拔高度，存储在 `high[N][N]` 数组中。
  - 每个格子的标记信息，存储在 `flag[N][N]` 数组中，其中 `1` 表示路标，`0` 表示非路标。

- **统计路标数量**：
  - 遍历 `flag` 数组，统计路标的总数 `cnt_flat`。

- **选择起点**：
  - 找到第一个路标的位置 `(x1, y1)` 作为 BFS 的起点。

### 2. 二分查找与BFS结合

- **二分查找循环**：
  - 当 $l + 1 < r$ 时，继续搜索。
  - 计算中间值 $mid = \frac{l + r}{2}$。
  - 重置 BFS 的队列 `q` 和访问标记 `st`。
  - 调用 `check(mid)` 函数，判断在当前 $mid$ 下，是否所有路标都可以相互连通。
    - 如果可以连通，则更新右边界 $r = mid$。
    - 否则，更新左边界 $l = mid$。

- **`check(mid)` 函数**：
  - **初始化**：
    - 将起点 `(x1, y1)` 加入队列 `q`，并标记为已访问。
    - 初始化计数器 `cnt = 1`（起点本身是路标）。
  - **BFS遍历**：
    - 依次从队列中取出当前格子，遍历其四个相邻方向（东、西、南、北）。
    - 对于每个相邻格子 `(a, b)`：
      - 检查是否在网格范围内。
      - 检查是否已被访问。
      - 检查与当前格子的海拔高度差是否不超过 $mid$。
      - 如果满足上述条件，将其加入队列，并标记为已访问。
      - 如果该格子是路标，则计数器 `cnt` 增加。
      - 如果 `cnt` 达到 `cnt_flat`，则返回 `true`，表示所有路标已连通。
  - **返回结果**：
    - 如果 BFS 遍历结束后，`cnt` 未达到 `cnt_flat`，则返回 `false`，表示当前 $mid$ 不足以连通所有路标。

### 3. 为什么只从一个起点遍历就能得到正确答案

**核心原因**：**连通性**。

- **连通性定义**：在给定的 $D$ 下，两个格子相互连通，意味着存在一条路径，使得路径上任意两个相邻格子的高度差不超过 $D$。

- **连通分量**：
  - 如果所有路标都属于同一个连通分量，则说明任意两个路标之间都存在符合条件的路径。
  - 从一个路标出发进行 BFS，可以遍历整个连通分量中的所有格子和路标。

- **只需一个起点**：
  - 因为我们只关心是否所有路标都在同一个连通分量内。
  - 如果从一个路标出发的 BFS 能够访问到所有其他路标，说明所有路标都在同一个连通分量内。
  - 反之，如果无法访问到所有路标，说明至少存在两个连通分量，各自包含部分路标。

**具体解释**：

1. **假设**：所有路标都需要互相可达。
2. **从一个路标出发的 BFS**：
   - BFS 会遍历所有在当前 $D$ 条件下与起点连通的格子。
   - 如果这些格子中包含所有路标，则说明所有路标已经连通。
3. **无需多个起点**：
   - 因为如果存在多个连通分量，每个连通分量内部的路标是可互相到达的，但不同连通分量之间的路标无法互相到达。
   - 从一个连通分量的起点出发的 BFS 不会跨越到其他连通分量，因此只需判断是否所有路标都被覆盖。

### 4. 代码优化与性能提升

尽管上述方法在理论上是正确的，但在实际应用中，尤其是当网格较大（$N, M \leq 500$）时，可能会遇到 **时间限制超出（TLE）** 的问题。这主要是因为：

- **BFS的多次执行**：
  - 在二分查找过程中，每次尝试一个 $mid$ 都需要执行一次 BFS。
  - BFS 的时间复杂度为 $O(NM)$，而二分查找的次数为 $O(\log D)$，其中 $D$ 是海拔高度差的范围（$10^9$）。
  - 整体时间复杂度接近 $O(NM \log D)$，对于 $N, M$ 较大的情况，可能会导致 TLE。

**解决方法**：采用**并查集（Union-Find）**结合**Kruskal 算法**的思想，避免多次 BFS 操作。

### 5. 使用并查集优化

**并查集（Union-Find）**是一种高效的数据结构，用于处理动态连通性问题。结合 **Kruskal 算法** 可以有效地找到最小的 $D$，使得所有路标连通。

**优化步骤**：

1. **定义所有可能的边**：
   - 遍历网格，定义每对相邻格子之间的边，记录它们的高度差。

2. **排序边**：
   - 按照高度差从小到大排序。

3. **逐步合并连通分量**：
   - 按照排序后的顺序，逐步合并相邻的格子。
   - 每次合并时，检查是否所有路标已经在同一个连通分量内。

4. **最早使所有路标连通的边的高度差即为所求的 $D$**。

**优势**：

- **减少重复操作**：避免了在二分查找中多次执行 BFS。
- **提高效率**：并查集的时间复杂度接近于 $O(1)$，整体时间复杂度为 $O(NM \log (NM))$，远优于原来的 $O(NM \log D)$。

### 6. 为什么优化后能避免 TLE

- **单次排序**：所有边只需要排序一次，复杂度为 $O(NM \log (NM))$。
- **单次遍历**：一次遍历所有边，进行并查集操作，复杂度为 $O(NM \alpha(NM))$，其中 $\alpha$ 是阿克曼函数的反函数，增长极其缓慢，几乎可以视为常数。
- **总复杂度**：总体复杂度降低到 $O(NM \log (NM))$，显著提高了效率，适用于大规模的网格数据。

## 总结

**原始方法**通过二分查找结合多次 BFS 来确定最小的难度系数 $D$，但在大规模网格下可能会遇到 TLE 问题。

**优化方法**采用并查集结合 Kruskal 算法，通过一次排序和一次遍历来确定最小的 $D$，显著提升了效率，避免了多次 BFS 导致的性能瓶颈。

**关键点**：

- **连通性判断**：只需从一个起点出发的 BFS 就能覆盖整个连通分量，判断所有路标是否在同一个连通分量内。
- **优化策略**：通过并查集和边排序，减少重复的连通性检查操作。

希望这些解释能帮助您更好地理解代码的思路以及优化的原因。如果您有更多问题，欢迎继续讨论！
           */
